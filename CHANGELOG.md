# 更新日志 (Changelog)

本文档记录项目的所有重要变更和版本历史。

---

## [v1.12] - 2025-10-14

### 🔨 重构
- **代码精简重构**：优化代码结构，提高可维护性
  - **变更1**：提取工具函数
    - 提取 `hasNum()` - 检查元素是否有.num
    - 提取 `isDef0()` - 检查元素是否是def0
    - 提取 `hasAncestorDef0()` - 检查元素是否有前置def0
    - 提取 `collectSubDefs()` - 收集子释义
    - 提取 `prioritizeTarget()` - 将target移到子释义最前面
  - **变更2**：将工具函数封装在 `pinByUnderline()` 内部
    - 避免污染全局作用域
    - 提高代码封装性
    - 只暴露 `pinByUnderline` 一个函数对外接口

### 📊 代码改进
- **行数优化**：从 358 行精简到 348 行（减少 10 行）
- **代码变更**：74 行插入，85 行删除（净减少 11 行）
- **函数数量**：从 1 个主函数增加到 1 个主函数 + 5 个内部工具函数
- **重复代码**：减少重复的条件判断和元素检查逻辑

### 🧪 测试验证
- ✅ 所有 9 个测试用例通过
- ✅ 测试输出文件与重构前完全一致
- ✅ 功能完全保持，无任何破坏性变更

### 🎯 设计原则
**代码可维护性** - 通过提取工具函数和封装作用域，提高代码可读性和可维护性

---

## [v1.11] - 2025-10-14

### 🔧 修复
- **关键修复**：解决"def0块中子释义处理逻辑缺失"的问题
  - **问题描述**：`くれる.html`中，虽然（二）块被正确识别和移动，但㋐（target）被单独移动，①和㋑没有跟着移动
  - **根本原因**：当`blockStartElement`是def0时，只考虑了target有.num的情况，没有处理target无.num（子释义）的情况
  - **解决方案**：在def0块处理逻辑中添加子释义处理分支

### 💡 核心洞察
def0块内的target也可能是子释义，需要特殊处理：
- **情况1**：target有.num（如一体.html的②）→ 按原逻辑处理
- **情况2**：target无.num（如くれる.html的㋐）→ 需要找到其主释义，一起移动

### 📝 修复代码示例
```javascript
if (blockStartElement是def0) {
    if (target无.num) {
        // 找到target所属的主释义
        const mainDef = 向前查找最近的有.num的def1;
        
        // 收集主释义及其所有子释义
        const subDefs = 收集主释义后面连续的无.num的def1;
        subDefs = [target, ...其他子释义]; // target优先
        
        // 重排：[def0, mainDef, ...subDefs, ...otherParts]
        nodesToMove = [def0, mainDef, ...subDefs, ...otherParts];
    } else {
        // target有.num，按原逻辑处理
    }
}
```

### ✅ 测试用例验证
- `くれる.html`：（二）①②㋐㋑（target=㋐） → （二）①㋐㋑②（㋐㋑跟随①移动）✅
- `一体.html`：（二）①②（target=②有.num） → （二）②①（走有.num分支）✅
- `易い.html`：③㋐㋑（target=㋑无.num） → ③㋑㋐（走def1分支）✅
- `はずす.html`：（一）①②③④⑤⑥（target=⑤有.num） → （一）⑤①②③④⑥（走有.num分支）✅

### 🎯 设计原则
**分支完整性** - 每个主要分支都要处理所有可能的子情况

---

## [v1.10] - 2025-10-11

### 🔧 修复
- **关键修复**：解决"子释义未跟随主释义移动"的问题
  - **问题描述**：`くれる.html`中，㋐（target，无.num）被置顶，但它的主释义①和兄弟子释义㋑没有被一起移动
  - **根本原因**：当target是无.num的def1时，它实际上是某个主释义（有.num的def1）的**子释义**

### 💡 核心洞察
无.num的def1不是独立的释义项，而是**从属于前面最近的有.num的def1**的子释义：
- 主释义（有.num）：①
- 子释义（无.num）：㋐、㋑
- 它们构成一个完整的释义单元：①㋐㋑

### 📝 修复代码示例
```javascript
if (blockStartElement是def1且有.num && targetDef无.num) {
    // 将主释义及其所有子释义作为一个整体
    const mainDef = blockStartElement;  // ①
    const subDefs = [];                 // ㋐、㋑
    
    // 收集主释义后面连续的所有无.num的def1
    for (let i = mainDefIndex + 1; i < fullBlockElements.length; i++) {
        if (element是无.num的def1) {
            subDefs.push(element);
        } else {
            break;  // 遇到有.num的def1，停止收集
        }
    }
    
    // 将target移到subDefs的最前面
    subDefs = [target, ...其他子释义];  // [㋐, ㋑]
    
    // 重排顺序：主释义 + 子释义（target优先）+ 其他元素
    nodesToMove = [①, ㋐, ㋑, ②];
}
```

### 🎯 设计原则
**释义单元完整性** - 主释义和其子释义必须作为一个整体移动

---

## [v1.9] - 2025-10-11

### 🔧 修复
- **关键修复**：解决"多连续编号项块识别失败"的问题
  - **问题描述**：`はずす.html`中，（一）块包含①②③④⑤⑥共6个连续编号项，但⑤（target）被误判为独立块
  - **根本原因**：只检查"直接前一个元素是否是def0"，但在同一个def0块内可以有多个连续的有.num的def1

### 💡 核心洞察
需要判断前面的有.num的def1是否**最终能追溯到def0**（而非只看直接前一个）

### 📝 判断标准
当遇到有.num的def1时，从它开始向前追溯：
- 跳过所有def1（无论有无.num）
- 如果最终找到def0 → 它属于def0块，target也可能属于该块，**继续查找**
- 如果最终没有元素 → 它是独立块起点，target与它平级，**停止查找**

### 🎯 设计原则
**深度追溯** - 通过递归向前查找来确定块的真实归属关系

---

## [v1.8] - 2025-10-11

### 🔧 修复
- **关键修复**：解决"同块编号项被误判为独立块"的问题
  - **问题描述**：`一体.html`中，（二）块内的②（target）被误认为独立块，只移动了②
  - **根本原因**：遇到前面的有`.num`的def1（如①）时立即停止，没有判断是否属于同一个def0块

### 💡 核心洞察
需要区分两种"前面有编号项"的情况：
1. **同块编号项**：（二）①② - ①和②都属于（二）块
2. **平级独立块**：⑫⑬ - ⑫和⑬是独立的块

### 📝 判断标准
当遇到前面的有`.num`的def1时，检查它的前面是否紧邻def0：
- **前面是def0** → target也属于这个def0块，继续向前查找def0
- **前面不是def0** → target与它平级独立，停止查找

### 🎯 设计原则
**上下文感知** - 通过检查相邻元素的关系来判断块的归属

---

## [v1.7] - 2025-10-11

### 🔧 修复
- **关键修复**：解决"平级释义被错误合并"的问题
  - **问题描述**：`載る.html`中，目标⑬（独立释义）被错误地和前一个⑫合并成一个块
  - **根本原因**：未能区分平级独立释义和主副从属关系

### 💡 核心洞察
target本身是否有`.num`决定了它与前面元素的关系：
- **target有`.num`** → 它是独立释义，遇到前一个有`.num`的就停止查找
- **target无`.num`** → 它是从属释义，需要找到所属的主释义

### 🎯 设计原则
- **独立性判断优先**：先看target是否独立（有`.num`且前面没有`def0`）
- **def0绝对优先**：即使target有`.num`，如果前面有`def0`，仍使用`def0`

---

## [v1.6] - 2025-10-11 🎉 稳定版

### ✨ 核心优化
- **完善块起点识别算法**，正确处理`def0`优先级和`def1`最近性

### 🎯 设计目标
1. `def0`是最高优先级的块标记
2. 对于`def1`块，使用**最近的**有`.num`的`def1`

### 📝 算法设计
```javascript
let firstDef1WithNum = null;  // 记录第一个（最近的）带.num的def1

while (向前遍历) {
    if (找到def0) {
        使用def0并立即停止;  // 最高优先级
    } else if (找到带.num的def1 && !firstDef1WithNum) {
        记录第一个;  // 最近的
        继续查找是否有def0;
    }
}

如果没找到def0 {
    使用firstDef1WithNum;  // 使用最近的def1
}
```

### 🔑 关键改进
- 只记录**第一个**（最近的）带`.num`的`def1`
- 找到后继续查找，给`def0`机会
- 最终根据是否找到`def0`来决定使用哪个

### ✅ 测试用例验证
- `まさか.html`：`（二）说明①②` → 使用（二）def0 ✅
- `易い.html`：`①②③㋐㋑` → 使用③（最近的def1）✅
- `代.html`：`（一）①②③` → `（一）②①③` ✅
- `回転.html`：`①②③④` → `④①②③` ✅

### 🎯 设计原则
**def0优先 + def1就近**

---

## [v1.5] - 2025-10-11 ⚠️ 已废弃

### ❌ 问题
- `def1`块采用"目标置顶"策略存在问题，已在v1.6中修正

### 📝 实现细节
智能重排策略 - 区分说明文字和编号项

---

## [v1.4] - 2025-10-11

### 🔧 修复
- **块边界识别问题**
  - **问题**：`def0`块内的带编号`def1`被错误识别为新块起点
  - **修复**：根据块起点类型采用不同的结束条件
    - `def0`块：只有遇到下一个`def0`时才结束
    - `def1`块：遇到下一个带`.num`的`def1`时才结束

---

## [v1.3] - 2025-10-11

### 🔧 修复
- **def0块标记处理问题**
  - **问题**：目标被移到`def0`前面，脱离了块
  - **修复**：根据块起点类型采用不同策略
    - 有`def0`块标记：`def0`保持在最前，目标紧跟其后
    - 无`def0`：目标排在绝对最前

---

## [v1.2] - 2025-10-11

### ✨ 功能优化
- 调整块内重排逻辑，实现"目标优先"原则
- 重排顺序：`目标 → 块起点 → 其他元素`

---

## [v1.1] - 2025-10-11

### 🔧 修复
- **块起点识别问题**
  - **问题**：目标`def1`有`.num`标记时被误认为块起点
  - **修复**：始终向前查找最近的块起点，`def0`优先级最高

---

## [v1.0] - 2025-10-10 🎉 初始版本

### ✨ 新功能
- 实现基于下划线的释义置顶功能
- 支持 Yomitan 词典弹出窗口
- 自动识别和重排释义块
- 高亮显示目标释义

---

## 图例说明

- 🎉 重要版本
- ✨ 新功能
- 🔧 修复
- 💡 核心洞察
- 📝 代码示例
- ✅ 测试验证
- 🎯 设计原则
- ⚠️ 警告/已废弃
- ❌ 已知问题

